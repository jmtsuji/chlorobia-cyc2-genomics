# Figure_1B.R
# Genomic context plotter for Figure 1, panel B, of the Chlorobia cyc2 paper
# Copyright Jackson M. Tsuji, Neufeld Research Group, 2019

# Load libraries
library(here)
library(stats4)
library(parallel)
library(BiocGenerics, warn.conflicts = FALSE)
library(futile.logger)
library(scales)
library(S4Vectors, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)
library(RColorBrewer)
library(grid)
library(ggplot2, quietly = TRUE, warn.conflicts = FALSE)
library(IRanges, warn.conflicts = FALSE)
library(GenomeInfoDb)
library(GenomicRanges)
library(Gviz)
library(ape)

######################################
## User variables
######################################
params <- list()
params$gff_summary_filename <- here::here("input_data", "Figure_1B_plotting_data.tsv")
params$plotting_colour_guide_filename <- here::here("input_data", "Figure_1B_plotting_colours.tsv")
params$pdf_filename <- here::here("plot", "Figure_1B_raw.pdf")
params$cyc2_info_filename <- NA
params$gff_directory <- NA
params$threads <- 4
params$buffer_length <- 5000
params$run_mode <- "normal"
######################################

#' Grabs accession and product into from a provided GFF attribute entry
#' 
#' @description 
#' GFF files come with an 'attributes' column of miscellaneous attributes separated by semicolons.
#' This function grabs selected 'attributes' out of a provided attribute string from a GFF file
#' @param unparsed_gff_attribute_string input character vector of length one - a GFF attributes entry
#' @return a tibble with two columns ('accession', 'product') and one row (for the single parsed entry)
#' @export
parse_gff_attributes <- function(unparsed_gff_attribute_string) {
  
  attributes_unparsed <- strsplit(unparsed_gff_attribute_string, split = ";")[[1]]
  
  # Get the accession number (either in the protein_id or locus_tag field depending on whether the GFF is from NCBI or prokka)
  test_protein_ID <- length(grep(x = attributes_unparsed, pattern = "^protein_id="))
  test_locus_tag <- length(grep(x = attributes_unparsed, pattern = "^locus_tag="))
  
  if (test_protein_ID == 1 && test_locus_tag == 1) {
    # Use protein_id over locus_tag, BUT throw a warning -- I don't know if this will mess things up.
    accession <- gsub(x = attributes_unparsed[grep(x = attributes_unparsed, pattern = "^protein_id=")], 
                      pattern = "^protein_id=", replacement = "")
    flog.warn(glue::glue(accession, ": found protein_id and locus_tag. Defaulting to protein_id."))
  } else if (test_protein_ID == 1) {
    flog.debug("Setting accession parsing mode to 'protein_ID'")
    accession <- gsub(x = attributes_unparsed[grep(x = attributes_unparsed, pattern = "^protein_id=")], 
                      pattern = "^protein_id=", replacement = "")
  } else if (test_locus_tag == 1) {
    flog.debug("Setting accession parsing mode to 'locus_tag'")
    accession <- gsub(x = attributes_unparsed[grep(x = attributes_unparsed, pattern = "^locus_tag=")], 
                      pattern = "^locus_tag=", replacement = "")
  } else {
    # Neither entry is present
    flog.debug("Setting accession parsing mode to 'none'")
    accession <- NA
  }
  
  # Get the product
  product <- gsub(x = attributes_unparsed[grep(x = attributes_unparsed, pattern = "^product=")], 
                  pattern = "^product=", replacement = "")
  
  return(tibble(accession = accession, product = product))
  # Consider adding 'gene' - a helpful summary name also generated by prokka (but not in NCBI)
  
}

#' Reads CDS entries from provided GFF filename and grabs accession and product attributes
#' 
#' @description N.B., for now, this function requires that the GFF file was generated by either NCBI or using prokka
#' @param gff_filename input character vector with the name of the GFF file (NOT path)
#' @param gff_directory input character vector with the directory of the GFF file
#' @param threads optional input numeric vector with the number of threads used to parse the GFF attributes
#' @return a dataframe of the parsed GFF content
#' @export
read_gff_cds <- function(gff_filename, gff_directory, threads = 1) {
  
  gff_file <- ape::read.gff(file = file.path(gff_directory, gff_filename), GFF3 = TRUE)
  gff_file[] <- lapply(gff_file, as.character) # make all characters; see https://stackoverflow.com/a/2851213 (accessed Nov 28, 2018)
  
  # Filter down to features and columns of interest
  gff_file <- dplyr::filter(gff_file, type == "CDS") %>%
              dplyr::select(seqid, source, start, end, strand, attributes)
  
  # Get attributes of interest
  gff_attributes <- dplyr::bind_rows(mclapply(gff_file$attributes, parse_gff_attributes, mc.cores = threads))
  
  # Bind onto the main table
  gff_file <- dplyr::bind_cols(gff_file, gff_attributes)
  gff_file$attributes <- NULL
  
  # Final cleanup
  gff_file$start <- as.numeric(gff_file$start)
  gff_file$end <- as.numeric(gff_file$end)
  
  return(gff_file)
  
}

#' Pulls contigs containing the gene of interest and optionally trims to some buffer length around the entry
#' 
#' @param gff_file input data frame of parsed GFF information by read_gff_cds()
#' @param cyc2_accession input character vector with the accession of the gene of interest
#' @param buffer_length optional input numeric vector with the number of bases on the left/right of the gene to trim to
#' @return a dataframe of the subsetted/trimmed GFF content; same columns as input data frame
#' @export
subset_features_from_gff <- function(gff_file, cyc2_accession, buffer_length = NA) {
  # Find the accession
  # TODO - add a check to make sure just one row was found
  accession_row <- grep(x = gff_file$accession, pattern = cyc2_accession)
  cyc2_contig_ID <- gff_file$seqid[accession_row]
  
  # Get the GFF info for the contig of interest
  gff_file_contig_only <- dplyr::filter(gff_file, seqid == cyc2_contig_ID)
  
  # If a buffer length was requested, then trim to the buffer length
  if (is.na(buffer_length) == FALSE) {
    # Get genes +/- defined length from cyc2
    cyc2_start_position <- gff_file$start[accession_row]
    cyc2_end_position <- gff_file$end[accession_row]
    start_cutoff <- cyc2_start_position - buffer_length
    end_cutoff <- cyc2_end_position + buffer_length
    
    # Clean up subsampling length based on contig length
    last_gene_position <- max(gff_file_contig_only$end)
    if (start_cutoff < 0) {
      flog.warn(paste(cyc2_accession, ": not enough bases available in contig for buffer length of ", buffer_length, 
                      ". Trimming to 0 on start side instead of requested ", start_cutoff, ".", sep = ""))
      start_cutoff <- 0
    }
    if (end_cutoff > last_gene_position) {
      flog.warn(paste(cyc2_accession, ": not enough bases available in contig for buffer length of ", buffer_length, 
                      ". Trimming to ", last_gene_position, " on start side instead of requested ", end_cutoff, ".", sep = ""))
      end_cutoff <- last_gene_position
    }
    
    # Now find genes that make the boundary of this region, and include any that are partially overlapping
    # TODO - assuming the table is ordered by position from 0 upward. Sort first to be safe.
    upstream_genes_logical <- gff_file_contig_only$start < start_cutoff
    upstream_genes_to_include <- gff_file_contig_only[upstream_genes_logical,]$end >= end_cutoff
    upstream_genes_to_include_start_pos <- gff_file_contig_only[upstream_genes_logical,]$start[upstream_genes_to_include]
    if (length(upstream_genes_to_include_start_pos) == 1) {
      flog.debug(paste("Extended start_cutoff from", start_cutoff, "to", upstream_genes_to_include_start_pos))
      start_cutoff <- upstream_genes_to_include_start_pos
    }
    
    downstream_genes_logical <- gff_file_contig_only$end > end_cutoff
    downstream_genes_to_include <- gff_file_contig_only[downstream_genes_logical,]$start <= end_cutoff
    downstream_genes_to_include_end_pos <- gff_file_contig_only[downstream_genes_logical,]$end[downstream_genes_to_include]
    if (length(downstream_genes_to_include_end_pos) == 1) {
      flog.debug(paste("Extended end_cutoff from", end_cutoff, "to", downstream_genes_to_include_end_pos))
      end_cutoff <- downstream_genes_to_include_end_pos
    }
    
    flog.debug(paste(cyc2_accession, ": Trimming contig ", cyc2_contig_ID, " to bases ", start_cutoff, " - ", end_cutoff, sep = ""))
    
    # Subset
    gff_file_cyc2_context <- dplyr::filter(gff_file_contig_only, start >= start_cutoff & end <= end_cutoff)
    
    return(gff_file_cyc2_context)
    
  } else if (is.na(buffer_length) == TRUE) {
    
    flog.debug(paste(cyc2_accession, ": not trimming contigs of the gene of interest; returning whole contig", sep = ""))
    return(gff_file_contig_only)
    
  }
}

#' Moves all positions in the GFF file by a given offset amount
#' 
#' @param gff_file input data frame of parsed GFF information in the style provided by read_gff_cds()
#' @param offset input numeric vector (integer) with the amout +/- to translate the base positions by
#' @return a dataframe of the translated GFF content; same columns as input data frame
#' @export
translate_gff_positions <- function(gff_file, offset) {
  
  gff_file$start <- gff_file$start + offset
  gff_file$end <- gff_file$end + offset
  
  return(gff_file)
  
}

#' Reverses the strand (+/-) orientation of all genes in the GFF file
#' 
#' @description A base 'position to invert' is required so that the function knows 
#' where to orient the flipped base coordinates around
#' @param gff_file input data frame of parsed GFF information in the style provided by read_gff_cds()
#' @param position_to_invert input numeric vector (integer) with the base position to center the inversion around
#' @param destination_position_post_inversion optional input numeric vector (integer) with the base position
#' to translate the position_to_invert to following the inversion. Will keep at position 0 if no input is provided.
#' @return a dataframe of the inverted GFF content; same columns as input data frame
#' @export
invert_gff_positions <- function(gff_file_single_contig, position_to_invert, destination_position_post_inversion) {
  
  # First translate the GFF so that the inversion centre is set to 0
  gff_file_single_contig <- translate_gff_positions(gff_file_single_contig, offset = (0 - position_to_invert))
  
  # Perform the inversion
  gff_file_inverted <- gff_file_single_contig
  gff_file_inverted$start <- gff_file_single_contig$end * -1
  gff_file_inverted$end <- gff_file_single_contig$start * -1
  gff_file_inverted$strand <- unlist(lapply(gff_file_inverted$strand, function(x) { 
      if (x == "+") {
        x <- "-"
      } else if (x == "-") {
        x <- "+"
      }
      return(x)
    }))
  
  # Order the rows by start position
  gff_file_inverted <- dplyr::arrange(gff_file_inverted, start)
  
  # Translate to the desitination position
  gff_file_inverted <- translate_gff_positions(gff_file_inverted, offset = (destination_position_post_inversion - 0))
  
  return(gff_file_inverted)
  
}

#' Transforms the position information in a GFF file to make a gene of interest start at a position of interest with
#' an orientation of interest
#' 
#' @param gff_file_single_contig input data frame of parsed GFF information in the style provided by read_gff_cds().
#' Can only contain info for a SINGLE CONTIG (or else position information will be distorted for the other contigs as well)
#' @param cyc2_accession input character vector with the accession of the gene to align
#' @param destination_start_position input numeric vector (integer) with the base position to move the start of the gene to.
#' Genes around the gene of interest will have their position information adjusted accordingly.
#' @param desired_strand optional input character vector of either "+" or "-" - the desired orientation of the gene of 
#' interest after the alignment. Defaults to "+".
#' @return a dataframe of the aligned GFF content; same columns as input data frame
#' @export
align_gff_features <- function(gff_file_single_contig, cyc2_accession, destination_start_position, desired_strand = "+") {
  
  # Get cyc2 info
  cyc2_gff_info <- dplyr::filter(gff_file_single_contig, accession == cyc2_accession)
  # TODO - confirm this is only one row long!
  
  # If the strand is already correct, then simply perform a translation
  if (cyc2_gff_info$strand == desired_strand) {
    flog.debug(paste(cyc2_accession, ": Translating GFF to make gene of interest start at '", 
                     destination_start_position, "'.", sep = ""))
    gff_file_single_contig <- translate_gff_positions(gff_file_single_contig, 
                                                      offset = (destination_start_position - cyc2_gff_info$start))
    
    # Determine where the start/ends of the contig are and throw a warning if the plot will go past this.
    
    
  } else if (cyc2_gff_info$strand != desired_strand) {
    # Otherwise, then also flip the positions
    flog.debug(paste(cyc2_accession, ": Flipping GFF to make gene of interest on strand '", desired_strand, 
                     "'.", sep = ""))
    
    # Note that the end of the cyc2 will become the start, so the end is used as the inversion point
    gff_file_single_contig <- invert_gff_positions(gff_file_single_contig, 
                                                   position_to_invert = cyc2_gff_info$end, 
                                                   destination_position_post_inversion = destination_start_position)
    
    # Determine where the start/ends of the contig are and throw a warning if the plot will go past this.
    
  }
  
  return(gff_file_single_contig)
  
}

#' Re-labels the gene of interest in the 'product' column of a GFF file as 'cyc2'
#' 
#' @description This is a very specific function for the cyc2 project but could be generalized in the future if needed
#' @param gff_file input data frame of parsed GFF information in the style provided by read_gff_cds()
#' @param cyc2_accession input character vector with the accession of the gene to rename as 'cyc2'
#' @return a dataframe of the aligned GFF content; same columns as input data frame
#' @export
label_cyc2 <- function(gff_file, cyc2_accession) {
  gff_file$product[gff_file$accession %in% cyc2_accession] <- "cyc2"
  
  return(gff_file)
}

#' Chooses a nice colour scale for a discrete number of entries
#' 
#' @description Will try to choose a colour-blind friendly colour set if possible, but has to move to
#' less and less ideal colour schemes as the number_of_entries increases
#' @param number_of_entries input numeric vector (integer) with the number of entries that need colours
#' @return a character vector of colours of the same length as the number provided for the number_of_entries
#' @export
choose_discrete_colour_scale <- function(number_of_entries) {
  
  # Choose the best colour scale based on the number of entries to be plotted
  if ( number_of_entries == 2 ) {
    colour_palette <- RColorBrewer::brewer.pal(n = 3, name = "Dark2")[c(1,2)]
  } else if ( number_of_entries <= 8 ) {
    colour_palette <- RColorBrewer::brewer.pal(n = number_of_entries, name = "Dark2")
  } else if ( number_of_entries <= 12 ) {
    colour_palette <- RColorBrewer::brewer.pal(n = number_of_entries, name = "Set3")
  } else if ( number_of_entries > 12 ) {
    colour_palette <- scales::hue_pal(h = c(20,290))(number_of_entries)
  } else {
    stop("Something is wrong with the number_of_entries ('", number_of_entries, "'). Is it non-numeric? Exiting...")
  }
  
  return(colour_palette)
  
}

#' Auto-generates suggested colours based on the number of unique "product" names in the GFF file
#' 
#' @param gff_data input list of data frames of GFF information in the style provided by read_gff_cds()
#' @return the same list but with a "colour" column for all entries in the data frames contained
#' @export
generate_feature_colours <- function(gff_data) {
  
  # Get the unique product names from the data
  unique_descriptions <- unique(dplyr::bind_rows(gff_data)$product)
  description_colours <- choose_discrete_colour_scale(length(unique_descriptions))
  
  # Make into a table
  labelling_table <- tibble(product = unique_descriptions, colour = description_colours)
  
  return(labelling_table)
  
}

#' Adds column for 'genome' and combines GFFs into a single tibble
#' 
#' @param gff_data input list of data frames of GFF information in the style provided by read_gff_cds().
#' **Names of lists MUST be the genome names!**
#' @return the GFF data collapsed into a single tibble
#' @export
combine_gff_tables <- function(gff_data) {
  
  combined_table <- lapply(names(gff_data), function(x) {
    gff_data_withGenome <- gff_data[[x]]
    gff_data_withGenome$genome <- x
    return(gff_data_withGenome)
  })

  combined_table <- dplyr::bind_rows(combined_table)
  
  return(combined_table)
}

#' Takes the output of combine_gff_tables and returns it to the state of the original list of tibbles
#' 
#' @param combined_gff_table input data frame in the format provided by combine_gff_tables()
#' @return the GFF data as a series of data frames in a list
#' @export
separate_gff_tables <- function(combined_gff_table) {
  
  genome_names <- unique(combined_gff_table$genome)
  separated_gff_tables <- lapply(genome_names, function(x) {
    separated_table <- dplyr::filter(combined_gff_table, genome == x)
    separated_table$genome <- NULL
    return(separated_table)
  })
  names(separated_gff_tables) <- genome_names
  
  return(separated_gff_tables)
  
}

#' Makes a Gviz annotation track for an input GFF file
#' 
#' @param gff_file input data frame in the format provided by combine_gff_tables()
#' @param genome_name the name of the genome (for displaying on the plot)
#' @return the GFF data as a series of data frames in a list
#' @export
create_annotation_track <- function(gff_file, genome_name) {
  
  annotation_track <- Gviz::AnnotationTrack(start = gff_file$start, 
                                            end = gff_file$end, 
                                            feature = gff_file$product, 
                                            fill = gff_file$colour,
                                            genome = genome_name, name = genome_name, 
                                            strand = gff_file$strand, chromosome = "chrNA", 
                                            arrowHeadMaxWidth = 15, col = "black")
  
  return(annotation_track)
  
}

#' Summary function to create a user template if the provided filename does not exist, 
#' or to read the file and generate a plot if it does exist
#' 
#' @description Only gff_summary_filename is required. But add the rest if you want to read in your data into
#' this script for the first time. This is a general master function for reading data into the workflow.
#' @param gff_summary_filename Input character vector of either 1) the filepath where you want to save parsed GFF input to,
#' or 2) the filepath of pre-parsed GFF info (e.g., user-modified) that you want to re-load into this script.
#' @param cyc2_info_filename Input character vector containing the filepath to a TSV-format data frame.
#' The data frame should contain three columns: 'genome' (name for plotting), 'cyc2_accession' (within the GFF file),
#' and 'gff_filename' (the file name, with NO DIRECTORY PATH) of the GFF file associated with the genome. All GFFs
#' MUST be in the same gff_directory for the script to run.
#' @param gff_directory input character vector with the directory of the GFF file
#' @param buffer_length optional input numeric vector with the number of bases on the left/right of the gene to trim to
#' @param threads optional input numeric vector with the number of threads used to parse the GFF attributes
#' @return the GFF data as a series of data frames in a list
#' @export
process_gff_data <- function(gff_summary_filename, cyc2_info_filename = NA, gff_directory = NA, 
                             buffer_length = NA, threads = 1) {
  if (is.na(cyc2_info_filename) == FALSE) {
    # Load the info table
    cyc2_info <- as_tibble(read.table(cyc2_info_filename, sep = "\t", header = TRUE, stringsAsFactors = FALSE))
    
    # Load the GFF files
    flog.info("Loading GFF files (can take time to parse...)")
    gff_data <- lapply(cyc2_info$gff_filename, function(x) {read_gff_cds(x, gff_directory, threads)})
    names(gff_data) <- cyc2_info$cyc2_accession
    
    # Trim to cyc2 context zone
    flog.info("Trimming to cyc2 zone")
    gff_data_trimmed <- lapply(cyc2_info$cyc2_accession, 
                               function(x) {subset_features_from_gff(gff_data[[x]], x, buffer_length)})
    names(gff_data_trimmed) <- cyc2_info$cyc2_accession
    
    # Align the cyc2 sequences within the context and set at the middle of the context zone
    flog.info("Aligning genes")
    gff_data_aligned <- lapply(cyc2_info$cyc2_accession, 
                               function(x) {align_gff_features(gff_data_trimmed[[x]], x, destination_start_position = 0)})
    names(gff_data_aligned) <- cyc2_info$cyc2_accession
    
    # Add cyc2 label to cyc2
    flog.info("Adding cyc2 label")
    gff_data_aligned <- lapply(cyc2_info$cyc2_accession, 
                               function(x) {label_cyc2(gff_data_aligned[[x]], x)})
    names(gff_data_aligned) <- cyc2_info$genome
    
    # Export for user to work with
    flog.info(paste("Exporting summary file to '", gff_summary_filename, "'", sep = ""))
    write.table(combine_gff_tables(gff_data_aligned), file = gff_summary_filename,
                row.names = FALSE, col.names = TRUE, sep = "\t")
  } else {
    
    # Read in the user-modified GFF table and re-separate into a list of data frames
    gff_data_aligned <- read.table(gff_summary_filename, sep = "\t", header = TRUE, stringsAsFactors = FALSE)
    gff_data_aligned <- separate_gff_tables(gff_data_aligned)
    
  }
  
  return(gff_data_aligned)
}


main <- function(params) {
  
  # Report settings to user
  flog.info("Running plot_cyc2_genomic_context.R")
  flog.info(paste("gff_summary_filename:", params$gff_summary_filename))
  flog.info(paste("plotting_colour_guide_filename:", params$plotting_colour_guide_filename))
  flog.info(paste("pdf_filename:", params$pdf_filename))
  flog.info(paste("cyc2_info_filename:", params$cyc2_info_filename))
  flog.info(paste("gff_directory:", params$gff_directory))
  flog.info(paste("buffer_length:", params$buffer_length))
  flog.info(paste("run_mode:", params$run_mode))
  flog.info(paste("threads:", params$threads))
  
  if (file.exists(params$gff_summary_filename) == TRUE) {
    flog.info("Reading user-provided GFF position info...")
    gff_data_aligned <- process_gff_data(params$gff_summary_filename)
  } else {
    flog.info("Parsing input GFF files")
    gff_data_aligned <- process_gff_data(params$gff_summary_filename, params$cyc2_info_filename, params$gff_directory, 
                                         params$buffer_length, params$threads)
    
    if (params$run_mode != "auto") {
      flog.info("Saved trimmed/aligned GFF file for user to examine and modify, then re-submit to this script as 
              'gff_summary_filename' for plotting. Exiting...")
      quit(save = "no", status = 0)
    }
    
  }
  
  # Determine colours unless user has already provided them
  if (file.exists(params$plotting_colour_guide_filename) == TRUE) {
    flog.info("Reading user-provided colouring table...")
    colouring_table <- read.table(params$plotting_colour_guide_filename, sep = "\t", header = TRUE, stringsAsFactors = FALSE, 
                                  comment.char = "")
  } else {
    flog.info("Determining plot colours")
    colouring_table <- generate_feature_colours(gff_data_aligned)
    flog.info(paste("Writing auto-determined plot colours to file '", params$plotting_colour_guide_filename, "'", sep = ""))
    write.table(colouring_table, file = params$plotting_colour_guide_filename, sep = "\t", row.names = FALSE, col.names = TRUE)
    
    if (params$run_mode != "auto") {
      flog.info("Saved colour guide file for user to examine and modify, then re-submit to this script as 
              'plotting_colour_guide_filename' for plotting. Exiting...")
      quit(save = "no", status = 0)
    }
    
  }
  
  # Bind the colours onto the main gff files
  genome_names <- names(gff_data_aligned)
  gff_data_aligned <- lapply(names(gff_data_aligned), 
                                  function(x) {dplyr::left_join(gff_data_aligned[[x]], colouring_table, by = "product")})
  names(gff_data_aligned) <- genome_names
  
  # Make Gviz tracks
  flog.info("Generating plot")
  annotation_tracks <- lapply(names(gff_data_aligned), 
                              function(x) {create_annotation_track(gff_data_aligned[[x]], x)})
  genome_track <- Gviz::GenomeAxisTrack(fontcolor = "black", fontsize = 12)
  
  plotting_list <- append(annotation_tracks, genome_track)
  
  pdf(file = params$pdf_filename, width = 7, height = 5)
  cyc2_context_plot <- Gviz::plotTracks(plotting_list, stacking = "dense",
                                 groupAnnotation = "feature", fontcolor.feature = "transparent",
                                 chromosome = "chrNA", cex.title = 1, rotate.title = 0,
                                 title.width = 5, col.title = "black", col = "black",
                                 background.title = "white", box.legend = TRUE, legend = TRUE)
  dev.off()
  
  flog.info("Finished")
  
}

main(params)
