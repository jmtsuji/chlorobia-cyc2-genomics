### Method to find ribosomal proteins and make protein tree from input genome bins
## **VERSION 2** after major issues with version 1
# Jackson M. Tsuji
# May 20, 2018
# Server directory (neufeldserver): /Hippodrome/jmtsuji/180520_ribosomal_protein_tree_vs2

### Background
# Ribosomal proteins used by Hug group (16 total)
	# rpL:
	# 2
	# 3
	# 4
	# 5
	# 6
	# 14
	# 15
	# 16
	# 18
	# 22
	# 24

	# rpS:
	# 3
	# 8
	# 10
	# 17
	# 19
	# Note that Laura warned to watch out for gene name look-alikes that are actually non-homolgous genes.

## Made conda install for prokka
#conda create -y -n prokka python=3.6
#conda install -y -n prokka -c conda-forge -c bioconda prokka

source activate prokka

work_dir="/Hippodrome/jmtsuji/180520_ribosomal_protein_tree_vs2"
rp_list="${work_dir}/riboprotein_prokka_names.list"
cd ${work_dir}

mkdir -p 01_input_genomes 02_prokka 03_riboproteins 04_tree/input
# Then copied all input reference genomes + bins into 01_input_genomes. All end in *.fa.
# Also made list of prokka names for all riboproteins and saved in main ${work_dir} as riboprotein_prokka_names.list

genomes=($(find ${work_dir}/01_input_genomes -iname "*.fa" | sort -h))

for genome in ${genomes[@]}; do
	name_base=${genome%.*}
	name_base=${name_base##*/}

	echo ${name_base}

	prokka --outdir 02_prokka/${name_base} --prefix ${name_base} --cpus 12 ${genome}
done

source deactivate


# Extract genes of interest
source activate riboprotein_tree
curation=0

for genome in ${genomes[@]}; do
	name_base=${genome%.*}
	name_base=${name_base##*/}

	echo ${name_base}

	# Find all riboproteins in the prokka annotations file
	cat ${rp_list} | xargs -I {} grep {}\$ 02_prokka/${name_base}/${name_base}.tsv | cut -d $'\t' -f 1,4,7 > 03_riboproteins/${name_base}_riboproteins_IDs.tsv

	# Get gene IDs for the riboproteins
	cut -d $'\t' -f 1 03_riboproteins/${name_base}_riboproteins_IDs.tsv > 03_riboproteins/${name_base}_riboproteins.list

	seqtk subseq 02_prokka/${name_base}/${name_base}.faa 03_riboproteins/${name_base}_riboproteins.list > 03_riboproteins/${name_base}_riboproteins.faa

	# Report a warning if not all were matched:
	grep "^>" 03_riboproteins/${name_base}_riboproteins.faa | cut -d ' ' -f 2- | sort -h > 03_riboproteins/${name_base}_riboproteins_check.tmp

	if [ $(head -n -1 ${rp_list} | sort -h | cmp - 03_riboproteins/${name_base}_riboproteins_check.tmp > /dev/null; echo $?) = 1 ]; then
		lines=$(cat 03_riboproteins/${name_base}_riboproteins_IDs.tsv | wc -l)
		echo "${name_base}: WARNING: Hit too few or too many riboproteins (${lines} total). Need to manually curate hits before proceeding."

		# Move files to a curation_needed folder and delete non-relevant ones
		mkdir -p 03_riboproteins/curation_needed
		mv 03_riboproteins/${name_base}_riboproteins_IDs.tsv 03_riboproteins/${name_base}_riboproteins.list 03_riboproteins/${name_base}_riboproteins.faa 03_riboproteins/curation_needed
		#rm 03_riboproteins/${name_base}_riboproteins.list 03_riboproteins/${name_base}_riboproteins.faa

		# Set curation to 1 if at least 1 sample needs curation
		curation=1

	fi
	rm 03_riboproteins/${name_base}_riboproteins_check.tmp

done

# Two options when curation is needed:
# 1. Duplicate genes were found -- here, one needs to be chosen.
# 2. Missing genes -- here, either remove the genome from the list OR delete that gene from consideration in the gene tree

# Made a list of all missing genes (7 total) and decided to remove in order to proceed.
# List at:
missing_list="/Hippodrome/jmtsuji/180520_ribosomal_protein_tree_vs2/03_riboproteins/curation_needed/curated/missing.list"

# Put list into memory as array
OFS=${IFS}
IFS=$'\t'
missing=($(cat ${missing_list}))
IFS=${OFS}

# Made list of riboproteins to ultimately use
used_rp_file="riboproteins_used.list"
cp ${rp_list} ${used_rp_file}
for i in ${missing[@]}; do
grep -v ${i}\$ ${used_rp_file} > ${used_rp_file}_tmp
mv ${used_rp_file}_tmp ${used_rp_file}
done

# Moved old analyses
mv 03_riboproteins 03_riboproteins_OLD
mkdir -p 03_riboproteins

# Repeated above code but with ${used_rp_file} and order-specific FAA building
for genome in ${genomes[@]}; do
	name_base=${genome%.*}
	name_base=${name_base##*/}

	echo ${name_base}

	# Find all riboproteins in the prokka annotations file
	cat ${used_rp_file} | xargs -I {} grep {}\$ 02_prokka/${name_base}/${name_base}.tsv | cut -d $'\t' -f 1,4,7 > 03_riboproteins/${name_base}_riboproteins_IDs.tsv

	# Get gene IDs for the riboproteins
	cut -d $'\t' -f 1 03_riboproteins/${name_base}_riboproteins_IDs.tsv > 03_riboproteins/${name_base}_riboproteins.list

	# Iteratively grab the FAA entries for the genome, to ensure that they are kept in the intended order.
	IDs=($(cat 03_riboproteins/${name_base}_riboproteins.list))
	printf "" > 03_riboproteins/${name_base}_riboproteins.faa
	for ID in ${IDs[@]}; do
		echo ${ID} > 03_riboproteins/${name_base}_tmp
		seqtk subseq 02_prokka/${name_base}/${name_base}.faa 03_riboproteins/${name_base}_tmp >> 03_riboproteins/${name_base}_riboproteins.faa
	done
	rm 03_riboproteins/${name_base}_tmp

	# Report a warning if not all were matched OR were in the incorrect order:
	grep "^>" 03_riboproteins/${name_base}_riboproteins.faa | cut -d ' ' -f 2- > 03_riboproteins/${name_base}_riboproteins_check.tmp

	if [ $(head -n -1 ${used_rp_file} | cmp - 03_riboproteins/${name_base}_riboproteins_check.tmp > /dev/null; echo $?) = 1 ]; then
		lines=$(cat 03_riboproteins/${name_base}_riboproteins_IDs.tsv | wc -l)
		echo "${name_base}: WARNING: Hit too few or too many riboproteins (${lines} total), OR FAA file not sorted correctly. Need to manually curate hits before proceeding."

		# Move files to a curation_needed folder and delete non-relevant ones
		mkdir -p 03_riboproteins/curation_needed
		mv 03_riboproteins/${name_base}_riboproteins_IDs.tsv 03_riboproteins/${name_base}_riboproteins.list 03_riboproteins/${name_base}_riboproteins.faa 03_riboproteins/curation_needed
		#rm 03_riboproteins/${name_base}_riboproteins.list 03_riboproteins/${name_base}_riboproteins.faa

		# Set curation to 1 if at least 1 sample needs curation
		curation=1

	fi
	rm 03_riboproteins/${name_base}_riboproteins_check.tmp

done


# Concatenate sequences (assume that FAA's are in order, as checked above)
# Initialize output file
printf "" > 04_tree/input/GSB_riboproteins_cat.faa

for genome in ${genomes[@]}; do
name_base=${genome%.*}
name_base=${name_base##*/}

echo ${name_base}

# Concatenate and rename. Also use 'sed' to get rid of any stop codons if present
(echo ">${name_base}" && grep -v "^>" 03_riboproteins/${name_base}_riboproteins.faa) | seqtk seq -A | sed -e 's/\*//g' >> 04_tree/input/GSB_riboproteins_cat.faa

done


# Align
clustalo -i 04_tree/input/GSB_riboproteins_cat.faa --seqtype=Protein --infmt=fa --outfmt=fa --threads=12 -v --force --wrap=100 -o 04_tree/input/GSB_riboproteins_cat_aligned.faa > 04_tree/input/GSB_riboproteins_cat_aligned_clustalo.log 2>&1

# Checked in Jalview -- looks good.

# Make tree
cd 04_tree
iqtree -s input/GSB_riboproteins_cat_aligned.faa -o Ignavibacterium_album_JCM_16511_genome -pre GSB_riboproteins_tree -nt AUTO -seed 63 -b 1000 -m MFP
# Started on 180520 at ~3:40 am EDT



# S.N. Adding more sequences to the alignment after the fact:
# make sure ${input_list%.*}.faa does not already exist! Will be appended to.
# input_list= [list of riboprotein accessions, in desired order]
# input_fasta = [faa file for genome]
# for i in $(seq 1 ${lines}); do j=$((${i}-1)); line=$(head -n ${j} ${input_list} | tail -n 1); echo ${line}; echo ${line} > tmp.tmp; seqtk subseq ${input_fasta} tmp.tmp >> ${input_list%.*}.faa; rm tmp.tmp; done
# Repeat for each genome to append
# Manually reduce to amount needed to fit into tree for each of the above files, as needed to match what was done for the rest of the tree
# genome_name= [final name of genome for fasta file]
# file_to_cat= [name of file to concatenate individual entries for]
# (echo ">${genome_name}" && grep -v "^>" ${file_to_cat}) | seqtk seq -A | sed -e 's/\*//g' >> GSB_riboproteins_cat_to_append.faa
# Repeat for each genome to append
# Append these to the end of the unaligned file
# Then use the alignment and tree-building code from directly above. Done!


