install.packages("littler")
install.packages("getopt")
install.packages("xlsx")
install.packages("rJava")
?library
install.packages("rJava")
install.packages("xlsx")
install.packages("rJava")
library(xlsx)
#####################################################
## Load required packages: ##########################
# TODO - add check function to see if these have been installed, and exit if not
library(getopt, quietly = TRUE, warn.conflicts = FALSE)
library(glue, quietly = TRUE, warn.conflicts = FALSE)
library(plyr, quietly = TRUE, warn.conflicts = FALSE)
suppressMessages(library(dplyr, quietly = TRUE, warn.conflicts = FALSE))
library(ggplot2, quietly = TRUE, warn.conflicts = FALSE)
library(grid, quietly = TRUE, warn.conflicts = FALSE)
library(reshape2, quietly = TRUE, warn.conflicts = FALSE)
library(xlsx, quietly = TRUE, warn.conflicts = FALSE)
library(xlsx, quietly = TRUE, warn.conflicts = FALSE)
library(xlsx, quietly = TRUE, warn.conflicts = FALSE)
library(xlsx, quietly = TRUE, warn.conflicts = FALSE)
library(xlsx, quietly = TRUE, warn.conflicts = FALSE)
is.null(opt$plate_data_filenames)
opt$plate_data_filenames <- TRUE
opt <- list()
opt$plate_data_filenames <- TRUE
is.null(opt$plate_data_filenames)
is.null(opt$sample_metadata_filename)
is.null(opt$plate_data_filenames) == FALSE
is.null(opt$sample_metadata_filename) == FALSE
is.null(opt$plate_data_filenames) == FALSE | is.null(opt$sample_metadata_filename) == FALSE
(is.null(opt$plate_data_filenames) == FALSE | is.null(opt$sample_metadata_filename) == FALSE)
opt$pre_parsed_data_file <- "yes"
is.null(opt$pre_parsed_data_file) == FALSE
(is.null(opt$plate_data_filenames) == FALSE | is.null(opt$sample_metadata_filename) == FALSE) && is.null(opt$pre_parsed_data_file) == FALSE
opt$pre_parsed_data_file <- NULL
(is.null(opt$plate_data_filenames) == FALSE | is.null(opt$sample_metadata_filename) == FALSE) && is.null(opt$pre_parsed_data_file) == FALSE
opt$parse_raw_plate_data
?glue
# Check if required columns exist. If they do not, exit early.
required_colnames <- c("Plate_number", "Well", "Absorbance", "Sample_name", "Sample_type", "Blanking_group", "Dilution_factor", "Standard_conc")
??glue
# Check if required columns exist. If they do not, exit early.
required_colnames <- c("Plate_number", "Well", "Absorbance", "Sample_name", "Sample_type", "Blanking_group", "Dilution_factor", "Standard_conc")
glue::collapse(required_colnames)
?collapse
glue::collapse(required_colnames, sep = ", ")
paste("ERROR: Missing at least one required table column; see README.md. You need at least: '", glue::collapse(required_colnames, sep = ", ") ,"'. Exiting...", sep = "")
?group_by
?dplyr::group_by()
1 - NA
source('~/.active-rstudio-document')
?file.path
file.path("/base/dir", c("1.txt", "2.txt"))
?log
?logger
source("https://bioconductor.org/biocLite.R")
biocLite("dada2")
remove.packages("yaml")
install.packages("yaml")
source("https://bioconductor.org/biocLite.R")
biocLite("BiocUpgrade")
biocLite("ggtree")
source("https://bioconductor.org/biocLite.R")
?write.table
library(ggtree)
TRUE || FALSE
TRUE && FALSE
?select
data(mtcars)
str(mtcars)
str(select(mtcars, gear, everything()))
library(dplyr)
str(select(mtcars, gear, everything()))
str(select(mtcars, -gear)
)
?setdiff
a <- ("One", "Two", "Three")
b <- ("One", "Four", "Five")
a <- c("One", "Two", "Three")
b <- c("One", "Four", "Five")
union(a,b)
intersect(a,b)
length(shared_entries)
shared_entries <- intersect(a, b)
length(shared_entries)
max(length(a), length(b))
a <- c("One", "Two", "Three")
b <- c("One", "Four", "Five", "Six")
shared_entries <- intersect(a, b)
length(shared_entries)
max(length(a), length(b))
longest_initial_entry <- max(length(a), length(b))
?timestamp
timestamp
timestamp(stamp = date())
##------ Tue Nov 13 09:24:47 2018 ------##
library(roxygen2)
install.packages("roxygen2")
library(roxygen2)
?library
#####################################################
## Load required packages: ##########################
library(roxygen2)
library(getopt)
library(futile.logger)
library(plyr)
library(tidyverse, quietly = TRUE)
library(ggtree)
library(ggtree, warn.conflicts = FALSE)
library(reshape2)
setwd("/home/jmtsuji/Research_General/PhD/04b_Metagenome_resequencing_F2015/10_ATLAS_re_analysis/15_final_zenodo_code/Chlorobia_cyc2_code/Figure_S1_ANI/")
library(here)
library(plyr)
library(dplyr)
library(tidyverse, quietly = TRUE, warn.conflicts = FALSE)
library(ggtree, quietly = TRUE, warn.conflicts = FALSE)
library(reshape2, warn.conflicts = FALSE)
library(egg)
here::here("Chlorobia_FastANI.txt")
here::here("Chlorobia_FastANI_results.txt")
here::here("Chlorobia_riboprotein_tree.treefile")
here::here("Chlorobia_naming_info.tsv")
??here
setwd("/home/jmtsuji/Research_General/PhD/04b_Metagenome_resequencing_F2015/10_ATLAS_re_analysis/15_final_zenodo_code/Chlorobia_cyc2_code/Figure_S1_ANI/")
library(here)
library(plyr, warn.conflicts = FALSE)
library(tidyverse, quietly = TRUE, warn.conflicts = FALSE)
library(ggtree, quietly = TRUE, warn.conflicts = FALSE)
library(reshape2, warn.conflicts = FALSE)
library(egg, warn.conflicts = FALSE)
here::here("Chlorobia_FastANI_results.txt")
here::here("data", "Chlorobia_FastANI_results.txt")
# setwd("/home/jmtsuji/Research_General/PhD/04b_Metagenome_resequencing_F2015/10_ATLAS_re_analysis/15_final_zenodo_code/Chlorobia_cyc2_code/Figure_S1_ANI/")
fastani_data_filepath <- here::here("data", "Chlorobia_FastANI_results.txt")
phylogenetic_tree_filepath <- here::here("data", "Chlorobia_riboprotein_tree.treefile")
Chlorobia_naming_table_filepath <- here::here("data", "Chlorobia_naming_info.tsv")
output_pdf_filepath <- here::here("Figure_S1_raw.pdf")
bootstrap_cutoff <- 50
tree_root <- "Ignavibacterium_album_JCM_16511_outgroup"
# Load ANI table and add headers to ANI data based on tool manual
ANI_data <- tibble::as_tibble(read.table(fastani_data_filepath, sep = "\t", header = FALSE, stringsAsFactors = FALSE))
colnames(ANI_data) <- c("query_genome", "reference_genome", "ANI_value", "n_fragment_mappings", "n_query")
# Load Chlorobia naming table
Chlorobia_names <- tibble::as_tibble(read.table(Chlorobia_naming_table_filepath, sep = "\t", header = TRUE, stringsAsFactors = FALSE))
# Simplify FastANI names
ANI_data$query_genome <- plyr::mapvalues(ANI_data$query_genome, from = Chlorobia_names$fastani_name, to = Chlorobia_names$tree_name)
# Load ANI table and add headers to ANI data based on tool manual
ANI_data <- tibble::as_tibble(read.table(fastani_data_filepath, sep = "\t", header = FALSE, stringsAsFactors = FALSE))
colnames(ANI_data) <- c("query_genome", "reference_genome", "ANI_value", "n_fragment_mappings", "n_query")
# Load Chlorobia naming table
Chlorobia_names <- tibble::as_tibble(read.table(Chlorobia_naming_table_filepath, sep = "\t", header = TRUE, stringsAsFactors = FALSE))
# Load ANI table and add headers to ANI data based on tool manual
ANI_data <- tibble::as_tibble(read.table(fastani_data_filepath, sep = "\t", header = FALSE, stringsAsFactors = FALSE))
colnames(ANI_data) <- c("query_genome", "reference_genome", "ANI_value", "n_fragment_mappings", "n_query")
# Load Chlorobia naming table
Chlorobia_names <- tibble::as_tibble(read.table(Chlorobia_naming_table_filepath, sep = "\t", header = TRUE, stringsAsFactors = FALSE))
# Some quick math (didn't end up using this in the final plot, but it is interesting)
ANI_data$percent_fragments_mapped <- ANI_data$n_fragment_mappings / ANI_data$n_query * 100
# Load phylogenetic tree
phylo_tree <- ggtree::read.tree(phylogenetic_tree_filepath)
# Re-root the tree
tip_label_index <- match(x = tree_root, table = phylo_tree$tip.label)
phylo_tree <- ggtree::reroot(phylo_tree, node = tip_label_index)
# Plot the tree
tree_plot <- ggtree(phylo_tree, size = 1.5, colour = "black", ladderize = TRUE,
branch.length = 0.1) +
geom_treescale(x = 0.4, y = 10, linesize = 1, fontsize = 3, offset = 0.2, width = 0.2) +
geom_tiplab(align = TRUE, linetype = "dotted",
size = 0, offset = 0.1) +
geom_text2(aes(subset = (grepl(pattern = "^[0-9]+$", x = label) & !(isTip) & as.numeric(label) > bootstrap_cutoff),
label = as.numeric(label)),
nudge_x = -0.05, nudge_y = 0.4, size = 3) +
scale_y_discrete(expand = c(0,0.6)) # to manually make it correspond to the heatmap in y-coordinates
# Change the FastANI names to match the tree names
ANI_data$query_genome <- plyr::mapvalues(ANI_data$query_genome, from = Chlorobia_names$fastani_name, to = Chlorobia_names$tree_name)
ANI_data$reference_genome <- plyr::mapvalues(ANI_data$reference_genome, from = Chlorobia_names$fastani_name, to = Chlorobia_names$tree_name)
# Get the order of the tips in the tree plot
tip_order <- dplyr::filter(tree_plot$data, isTip == TRUE)
tip_order <- tip_order[order(tip_order$y, decreasing = TRUE),]$label
tip_order
# Check that the exact same genome names exist between the FastANI data and the tree
tip_order %in% ANI_data$query_genome
# Check that the exact same genome names exist between the FastANI data and the tree
alltrue(tip_order %in% ANI_data$query_genome)
# Check that the exact same genome names exist between the FastANI data and the tree
all.equal(tip_order, ANI_data$query_genome)
?sort
sort(tip_order)
# Check that the exact same genome names exist between the FastANI data and the tree
all.equal(sort(tip_order), sort(ANI_data$query_genome))
sort(tip_order)
sort(ANI_data$query_genome)
# Check that the exact same genome names exist between the FastANI data and the tree
all.equal(sort(tip_order), sort(unique(ANI_data$query_genome)))
library(futile.logger)
?glue
# Load ANI table and add headers to ANI data based on tool manual
flog.info(glue::glue_collapse("Loading ANI table '", fastani_data_filepath, "'"))
glue::glue_collapse("Loading ANI table '", fastani_data_filepath, "'")
fastani_data_filepath
glue_collapse("test")
library(glue, warn.conflicts = FALSE)
# Load ANI table and add headers to ANI data based on tool manual
flog.info(glue::glue_collapse("Loading ANI table '", fastani_data_filepath, "'"))
glue_collapse("test")
glue_collapse("Loading ANI table '"
)
fastani_data_filepath
# Load ANI table and add headers to ANI data based on tool manual
flog.info(glue::glue("Loading ANI table '", fastani_data_filepath, "'"))
# Load Chlorobia naming table
flog.info(glue::glue("Loading Chlorobia naming table '", Chlorobia_naming_table_filepath, "'"))
# Load phylogenetic tree
flog.info(glue::glue("Loading phylogenetic tree '", phylogenetic_tree_filepath, "'"))
# Check that the exact same genome names exist between the FastANI data and the tree
if (all.equal(sort(tip_order), sort(unique(ANI_data$query_genome))) == FALSE) {
flog.warn("FastANI labels and tree tips DO NOT MATCH. Results will be unreliable!")
} else if (all.equal(sort(tip_order), sort(unique(ANI_data$reference_genome))) == FALSE) {
flog.warn("FastANI labels and tree tips DO NOT MATCH. Results will be unreliable!")
}
flog.warn("FastANI labels and tree tips DO NOT MATCH. Results will be unreliable!")
# Load libraries
library(here)
library(futile.logger)
library(glue, warn.conflicts = FALSE)
library(plyr, warn.conflicts = FALSE)
library(tidyverse, quietly = TRUE, warn.conflicts = FALSE)
library(ggtree, quietly = TRUE, warn.conflicts = FALSE)
library(ape, warn.conflicts = FALSE)
library(maps, warn.conflicts = FALSE)
library(phytools, warn.conflicts = FALSE)
library(reshape2, warn.conflicts = FALSE)
library(egg, warn.conflicts = FALSE)
################################
# HARD-CODED plotting variables
# setwd("/home/jmtsuji/Research_General/PhD/04b_Metagenome_resequencing_F2015/10_ATLAS_re_analysis/15_final_zenodo_code/Chlorobia_cyc2_code/Figure_S1_ANI/")
fastani_data_filepath <- here::here("data", "Chlorobia_FastANI_results.txt")
phylogenetic_tree_filepath <- here::here("data", "Chlorobia_riboprotein_tree.treefile")
Chlorobia_naming_table_filepath <- here::here("data", "Chlorobia_naming_info.tsv")
output_pdf_filepath <- here::here("Figure_S1_raw.pdf")
bootstrap_cutoff <- 50
tree_root <- "Ignavibacterium_album_JCM_16511_outgroup"
################################
# Load ANI table and add headers to ANI data based on tool manual
flog.info(glue::glue("Loading ANI table '", fastani_data_filepath, "'"))
ANI_data <- tibble::as_tibble(read.table(fastani_data_filepath, sep = "\t", header = FALSE, stringsAsFactors = FALSE))
colnames(ANI_data) <- c("query_genome", "reference_genome", "ANI_value", "n_fragment_mappings", "n_query")
# Load Chlorobia naming table
flog.info(glue::glue("Loading Chlorobia naming table '", Chlorobia_naming_table_filepath, "'"))
Chlorobia_names <- tibble::as_tibble(read.table(Chlorobia_naming_table_filepath, sep = "\t", header = TRUE, stringsAsFactors = FALSE))
# Some quick math (didn't end up using this in the final plot, but it is interesting)
ANI_data$percent_fragments_mapped <- ANI_data$n_fragment_mappings / ANI_data$n_query * 100
# Load phylogenetic tree
flog.info(glue::glue("Loading phylogenetic tree '", phylogenetic_tree_filepath, "'"))
phylo_tree <- ggtree::read.tree(phylogenetic_tree_filepath)
# Re-root the tree
tip_label_index <- match(x = tree_root, table = phylo_tree$tip.label)
phylo_tree <- ggtree::reroot(phylo_tree, node = tip_label_index)
# Plot the tree
flog.info("Generaring the tree plot")
tree_plot <- ggtree(phylo_tree, size = 1.5, colour = "black", ladderize = TRUE,
branch.length = 0.1) +
geom_treescale(x = 0.4, y = 10, linesize = 1, fontsize = 3, offset = 0.2, width = 0.2) +
geom_tiplab(align = TRUE, linetype = "dotted",
size = 0, offset = 0.1) +
geom_text2(aes(subset = (grepl(pattern = "^[0-9]+$", x = label) & !(isTip) & as.numeric(label) > bootstrap_cutoff),
label = as.numeric(label)),
nudge_x = -0.05, nudge_y = 0.4, size = 3) +
scale_y_discrete(expand = c(0,0.6)) # to manually make it correspond to the heatmap in y-coordinates
# Change the FastANI names to match the tree names
flog.info("Matching FastANI table to tree tips")
ANI_data$query_genome <- plyr::mapvalues(ANI_data$query_genome, from = Chlorobia_names$fastani_name, to = Chlorobia_names$tree_name)
ANI_data$reference_genome <- plyr::mapvalues(ANI_data$reference_genome, from = Chlorobia_names$fastani_name, to = Chlorobia_names$tree_name)
# Get the order of the tips in the tree plot
tip_order <- dplyr::filter(tree_plot$data, isTip == TRUE)
tip_order <- tip_order[order(tip_order$y, decreasing = TRUE),]$label
# Check that the exact same genome names exist between the FastANI data and the tree
if (all.equal(sort(tip_order), sort(unique(ANI_data$query_genome))) == FALSE) {
flog.warn("FastANI labels and tree tips DO NOT MATCH. Results will be unreliable!")
} else if (all.equal(sort(tip_order), sort(unique(ANI_data$reference_genome))) == FALSE) {
flog.warn("FastANI labels and tree tips DO NOT MATCH. Results will be unreliable!")
}
factor(ANI_data$query_genome, levels = rev(tip_order), ordered = TRUE)
# Order the genomes in the FastANI table to correspond to the tree tip order
ANI_data$query_genome <- factor(ANI_data$query_genome, levels = rev(tip_order), ordered = TRUE)
ANI_data$reference_genome <- factor(ANI_data$reference_genome, levels = rev(tip_order), ordered = TRUE)
plyr::mapvalues(ANI_data$query_genome, from = Chlorobia_names$tree_name, to = Chlorobia_names$plotting_name)
# Change taxon names to those to appear in the final plot
ANI_data$query_genome <- plyr::mapvalues(ANI_data$query_genome, from = Chlorobia_names$tree_name, to = Chlorobia_names$plotting_name)
ANI_data$reference_genome <- plyr::mapvalues(ANI_data$reference_genome, from = Chlorobia_names$tree_name, to = Chlorobia_names$plotting_name)
# Put everything together and save
flog.info("Combining tree and heatmap; saving to '", output_pdf_filepath, "'")
output_pdf_filepath
# Put everything together and save
flog.info(glue::glue("Combining tree and heatmap; saving to '", output_pdf_filepath, "'"))
source('~/Research_General/PhD/04b_Metagenome_resequencing_F2015/10_ATLAS_re_analysis/15_final_zenodo_code/Chlorobia_cyc2_code/Figure_S1_ANI/Figure_S1.R')
library(tidyverse, quietly = TRUE, warn.conflicts = FALSE)
library(tidyverse, quietly = TRUE, warn.conflicts = FALSE)
# Load libraries
library(here)
library(futile.logger)
library(glue, warn.conflicts = FALSE)
library(plyr, warn.conflicts = FALSE)
library(tibble, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)
library(ggplot2, warn.conflicts = FALSE)
# library(tidyverse, quietly = TRUE, warn.conflicts = FALSE)
library(ggtree, quietly = TRUE, warn.conflicts = FALSE)
library(ape, warn.conflicts = FALSE)
library(maps, warn.conflicts = FALSE)
library(phytools, warn.conflicts = FALSE)
library(reshape2, warn.conflicts = FALSE)
library(egg, warn.conflicts = FALSE)
